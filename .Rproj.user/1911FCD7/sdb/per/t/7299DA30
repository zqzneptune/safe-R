{
    "collab_server" : "",
    "contents" : "compute_enrichments <- function(safe) {\n  \n  # Define neighborhood radius ---------------------------\n  \n  if (safe[[\"neighborhoodRadiusType\"]] == \"percentile\") {\n    r <- quantile(safe[[\"nodeDistance\"]], c(safe[[\"neighborhoodRadius\"]]),\n                  na.rm = TRUE, type = 1)\n    # Note: type=1 was chosen because it gives the same answer as MATLAB\n  }\n  \n  \n  # Define neighborhoods ---------------------------\n  \n  safe[[\"neighborhoods\"]] <- safe[[\"nodeDistance\"]] <= r\n  \n  \n  # Compute starting values ---------------------------\n  \n  NLBL <- length(safe[[\"nodeLabels\"]])\n  NGRP <- length(safe[[\"attributeNames\"]])\n  \n  if (safe[[\"background\"]] == \"map\") {\n    \n    # Total number of nodes on the map (in matrix format)\n    N <- matrix(data = NLBL, nrow = NLBL, ncol = NGRP)\n    \n    # Number of nodes (on the map) that are annotated to a given attribute\n    Ng <- matrix(rep(colSums(safe[[\"node2attribute\"]], na.rm = TRUE), each = NLBL), nrow = NLBL)\n  }\n  \n  # Number of nodes in each node's neighborhood\n  Ni <- rowSums(safe[[\"neighborhoods\"]], na.rm = TRUE)\n  \n  # Number of nodes in each node's neighborhood that are also annotated to each attribute\n  Nig <- safe[[\"neighborhoods\"]] %*% safe[[\"node2attribute\"]]\n  \n  \n  # Determine if we are dealing with binary or quantitative annotations ---------------------------\n  \n  \n  # Run the quantative schema ---------------------------\n  \n  nPermutations <- 1000\n  Sr <- array(data = NA, dim = c(NLBL, NGRP, nPermutations))\n  \n  for (r in 1:nPermutations) {\n    ixPerm <- sample(NLBL, size = NLBL, replace = FALSE)\n    Wr <- safe[[\"node2attribute\"]][ixPerm,]\n    Sr[,,r] <- safe[[\"neighborhoods\"]] %*% Wr\n  }\n  \n  if (safe[[\"annotationsign\"]] == \"both\") {\n    safe[[\"pval\"]] <- array(data = NA, dim = c(NLBL, NGRP, 2))\n  } else {\n    safe[[\"pval\"]] <- matrix(data = NA, nrow = NLBL, ncol = NGRP)\n  }\n  \n  for (grp in 1:NGRP) {\n    Sm <- rowMeans(Sr[,grp,], na.rm = TRUE)\n    Ss <- apply(Sr[,grp,], 1, sd, na.rm = TRUE)\n    Z <- (Nig[,grp] - Sm) / Ss\n    \n    if (safe[[\"annotationsign\"]] == \"highest\") {\n      safe[[\"pval\"]][,grp] <- pnorm(Nig[,grp], mean = Sm, sd = Ss, lower.tail = FALSE, log.p = FALSE)\n    } else if (safe[[\"annotationsign\"]] == \"lowest\") {\n      safe[[\"pval\"]][,grp] <- pnorm(Nig[,grp], mean = Sm, sd = Ss, lower.tail = TRUE, log.p = FALSE)\n    } else {\n      t1 <- pnorm(Nig[,grp], mean = Sm, sd = Ss, lower.tail = FALSE, log.p = FALSE)\n      t2 <- pnorm(Nig[,grp], mean = Sm, sd = Ss, lower.tail = TRUE, log.p = FALSE)\n      safe[[\"pval\"]][,grp,1] <- t1\n      safe[[\"pval\"]][,grp,1] <- t2\n    }\n    \n  }\n  \n  # Final adjustments ---------------------------\n  \n  safe[[\"opacity\"]] <- -log10(safe[[\"pval\"]])\n  \n  m <- safe[[\"MAX_LOG10_PVAL\"]]\n  safe[[\"opacity\"]][safe[[\"opacity\"]] > m] <- m\n  safe[[\"opacity\"]] <- safe[[\"opacity\"]] / m\n  \n  # Calculate the minimum opacity corresponding to significant enrichment (after Bonferroni multiple testing correction)\n  \n  safe[[\"thresholdOpacity\"]] <- -log10(safe[[\"THRESHOLD_ENRICHMENT\"]]/length(safe[[\"attributeIds\"]]))/safe[[\"MAX_LOG10_PVAL\"]]\n  \n  safe[[\"opacity_01\"]] <- safe[[\"opacity\"]] > safe[[\"thresholdOpacity\"]]\n  \n}",
    "created" : 1469222469911.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2816274743",
    "id" : "7299DA30",
    "lastKnownWriteTime" : 1469227938,
    "last_content_update" : 1469227938952,
    "path" : "~/Laboratory/Utils/R/Networks/safe/extras/compute_enrichments.R",
    "project_path" : "extras/compute_enrichments.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}